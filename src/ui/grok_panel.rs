//! Grok Parser Panel
//!
//! Provides UI for configuring and testing grok patterns for log parsing.

use crate::config::FileGrokConfig;
use crate::grok_parser::{CustomPattern, GrokConfig, GrokParser};
use crate::i18n::Translations as t;
use egui::{self, Color32, RichText, Ui};
use std::path::PathBuf;

/// Actions from the grok panel
#[derive(Debug, Clone)]
pub enum GrokPanelAction {
    /// No action
    None,
    /// Pattern changed (needs to reparse logs)
    PatternChanged,
    /// Configuration changed (needs to save)
    ConfigChanged,
    /// File-specific pattern changed
    #[allow(dead_code)]
    FilePatternChanged {
        path: PathBuf,
        config: Option<FileGrokConfig>,
    },
    /// Request sample log lines for AI assist
    RequestSampleLines,
}

/// State for editing a custom pattern
#[derive(Debug, Clone, Default)]
struct PatternEditor {
    /// Pattern name
    name: String,
    /// Pattern string
    pattern: String,
    /// Pattern description
    description: String,
    /// Example log line
    example: String,
    /// Display template for formatting output
    display_template: String,
    /// Pre-processor to apply before Grok matching
    pre_processor: crate::grok_parser::PreProcessor,
    /// Whether we're editing an existing pattern
    editing_index: Option<usize>,
    /// Whether the editor is open
    is_open: bool,
}

impl PatternEditor {
    fn clear(&mut self) {
        self.name.clear();
        self.pattern.clear();
        self.description.clear();
        self.example.clear();
        self.display_template.clear();
        self.pre_processor = crate::grok_parser::PreProcessor::None;
        self.editing_index = None;
        self.is_open = false;
    }

    fn load_from(&mut self, pattern: &CustomPattern, index: usize) {
        self.name = pattern.name.clone();
        self.pattern = pattern.pattern.clone();
        self.description = pattern.description.clone();
        self.example = pattern.example.clone();
        self.display_template = pattern.display_template.clone();
        self.pre_processor = pattern.pre_processor.clone();
        self.editing_index = Some(index);
        self.is_open = true;
    }
}

/// Grok parser panel component
pub struct GrokPanel {
    /// Whether grok parsing is enabled
    pub enabled: bool,
    /// Currently selected custom pattern index
    selected_custom: Option<usize>,
    /// Pattern editor state
    pattern_editor: PatternEditor,
    /// AI assist state
    ai_assist: AiAssistState,
    /// Current file path (for per-file settings)
    pub current_file_path: Option<PathBuf>,
    /// Whether current file uses file-specific pattern
    pub use_file_specific: bool,
}

/// State for AI-assisted pattern generation
#[derive(Debug, Clone, Default)]
pub struct AiAssistState {
    /// Generated prompt for LLM
    pub generated_prompt: String,
    /// Whether to auto-copy prompt when ready
    pub pending_copy_prompt: bool,
    /// Whether to show response editor
    pub show_response_editor: bool,
    /// JSON response from LLM
    pub json_response: String,
    /// Sample log lines
    pub sample_lines: Vec<String>,
    /// Error message
    pub error_message: Option<String>,
    /// Success message
    pub success_message: Option<String>,
    /// Parsed pattern from JSON (preview before applying)
    pub parsed_pattern: Option<AiGeneratedPattern>,
    /// Test result for parsed pattern
    pub test_result: Option<Result<Vec<(String, String)>, String>>,
    /// Whether the pattern has been tested (to avoid re-testing on every frame)
    pub pattern_tested: bool,
}

/// Pattern generated by AI
#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
pub struct AiGeneratedPattern {
    /// Pattern name
    pub name: String,
    /// Grok pattern string
    pub pattern: String,
    /// Display template
    pub display_template: String,
    /// Description (optional)
    #[serde(default)]
    pub description: String,
    /// Pre-processor for extracting log content from wrappers (e.g., JSON)
    /// If the log is wrapped in JSON like {"log": "actual log...", ...},
    /// set this to {"type": "json_field", "field": "log"}
    #[serde(default)]
    pub pre_processor: Option<AiPreProcessorConfig>,
}

/// Pre-processor configuration from AI response
#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum AiPreProcessorConfig {
    /// Extract a field from JSON
    JsonField { field: String },
}

impl AiPreProcessorConfig {
    /// Convert to the internal PreProcessor type
    pub fn to_pre_processor(&self) -> crate::grok_parser::PreProcessor {
        match self {
            AiPreProcessorConfig::JsonField { field } => {
                crate::grok_parser::PreProcessor::JsonField(field.clone())
            }
        }
    }
}

impl Default for GrokPanel {
    fn default() -> Self {
        Self::new()
    }
}

impl GrokPanel {
    /// Create a new grok panel
    pub fn new() -> Self {
        Self {
            enabled: false,
            selected_custom: None,
            pattern_editor: PatternEditor::default(),
            ai_assist: AiAssistState::default(),
            current_file_path: None,
            use_file_specific: false,
        }
    }

    /// Load state from config
    pub fn load_from_config(&mut self, config: &GrokConfig) {
        self.enabled = config.enabled;
        // Custom pattern selection would need to be matched by name
    }

    /// Save state to config
    pub fn save_to_config(&self, config: &mut GrokConfig) {
        config.enabled = self.enabled;
        config.builtin_pattern = None;
    }

    /// Set sample lines for AI assist
    pub fn set_sample_lines(&mut self, lines: Vec<String>) {
        self.ai_assist.sample_lines = lines;
        self.generate_ai_prompt();
    }

    /// Generate AI prompt from sample lines
    fn generate_ai_prompt(&mut self) {
        if self.ai_assist.sample_lines.is_empty() {
            self.ai_assist.generated_prompt.clear();
            return;
        }

        // Sample from different parts of the file to cover more cases
        let total_lines = self.ai_assist.sample_lines.len();
        let sample_count = 10.min(total_lines);

        let sample_text = if total_lines <= sample_count {
            // If we have 10 or fewer lines, use them all
            self.ai_assist
                .sample_lines
                .iter()
                .enumerate()
                .map(|(i, line)| format!("{}. {}", i + 1, line))
                .collect::<Vec<_>>()
                .join("\n")
        } else {
            // Sample from different parts of the file
            let step = total_lines / sample_count;
            (0..sample_count)
                .map(|i| {
                    let idx = (i * step + step / 2).min(total_lines - 1);
                    format!("{}. {}", i + 1, &self.ai_assist.sample_lines[idx])
                })
                .collect::<Vec<_>>()
                .join("\n")
        };

        self.ai_assist.generated_prompt = format!(
            r#"You are a log parsing expert. Analyze the following log lines and generate a Grok pattern to parse them.

Sample log lines (sampled from different parts of the file):
{}

Please analyze these log lines and return a JSON object with the following structure:
{{
    "name": "Pattern name describing the log format",
    "pattern": "The Grok pattern string to parse these logs",
    "display_template": "Display template using %{{field:format=...,color=...}} syntax",
    "description": "Brief description of what this pattern matches",
    "pre_processor": null or {{"type": "json_field", "field": "field_name"}}
}}

Requirements:
1. **IMPORTANT: Check if logs are wrapped in JSON structure first!**
   - If logs look like: {{"log": "actual log content...", "stream": "...", ...}}
   - Then set pre_processor to: {{"type": "json_field", "field": "log"}}
   - And write the Grok pattern to match the INNER content (e.g., "actual log content...")
   - Common wrapper fields: "log", "message", "msg", "content"
   
2. If logs are NOT wrapped in JSON, set pre_processor to null.

3. The Grok pattern should extract meaningful fields like timestamp, log level, message, etc.

4. Use standard Grok patterns like %{{TIMESTAMP_ISO8601}}, %{{LOGLEVEL}}, %{{GREEDYDATA}}, etc.

5. The display_template should use colors and formatting to make logs visually clear and readable.
   - For timestamps: Use format=%H:%M:%S or format=%Y-%m-%d %H:%M:%S with color=cyan
   - For log levels: 
     * ERROR: color=red,bold
     * WARN/WARNING: color=yellow,bold
     * INFO: color=green
     * DEBUG: color=blue
     * TRACE: color=magenta
   - For important fields (like component, module, thread): color=cyan
   - For messages: No color specification (uses default terminal color)
   - Example: "%{{timestamp:format=%H:%M:%S,color=cyan}} [%{{level:color=red,bold}}] %{{message}}"

6. **Color guidelines for light/dark mode compatibility:**
   - AVOID: color=gray (too light in light mode, too dark in dark mode)
   - AVOID: color=white (invisible in light mode)
   - PREFER: cyan, blue, magenta, green, yellow, red (work well in both modes)
   - Use bold for emphasis instead of relying on color alone

7. Return ONLY the JSON object, no additional text or explanation.

Common Grok patterns you can use:
- %{{TIMESTAMP_ISO8601:timestamp}} - ISO 8601 timestamp
- %{{HTTPDATE:timestamp}} - HTTP date format
- %{{SYSLOGTIMESTAMP:timestamp}} - Syslog timestamp
- %{{LOGLEVEL:level}} - Log level (ERROR, WARN, INFO, DEBUG, etc.)
- %{{IP:ip}} - IP address
- %{{IPORHOST:host}} - IP or hostname
- %{{WORD:field}} - Single word
- %{{DATA:field}} - Any data (non-greedy)
- %{{GREEDYDATA:field}} - Any data (greedy, usually for message)
- %{{NUMBER:field}} - Number
- %{{INT:field}} - Integer
- %{{QUOTEDSTRING:field}} - Quoted string
- %{{URIPATHPARAM:request}} - URI path with parameters

Available colors for display_template (compatible with both light and dark modes):
- Recommended: color=red, color=green, color=yellow, color=blue, color=magenta, color=cyan
- Avoid: color=gray, color=white (poor contrast in certain modes)
- Additional formatting: bold, italic, underline
- Combine multiple formats with commas: color=red,bold or format=%H:%M:%S,color=cyan
- For main message text: omit color to use default terminal color (best compatibility)

Example for JSON-wrapped Nginx error log:
Input: {{"log":"2024/01/15 10:30:45 [error] 123#123: *456 connect() failed...\\n","stream":"stderr"}}
Output:
{{
    "name": "Nginx Error Log (JSON wrapped)",
    "pattern": "%{{DATA:timestamp}} \\[%{{WORD:level}}\\] %{{DATA:pid}}: \\*%{{INT:connection}} %{{GREEDYDATA:message}}",
    "display_template": "%{{timestamp:color=cyan}} [%{{level:color=red,bold}}] %{{message}}",
    "description": "Nginx error log format extracted from Docker/Kubernetes JSON wrapper",
    "pre_processor": {{"type": "json_field", "field": "log"}}
}}"#,
            sample_text
        );
    }

    /// Parse JSON response from AI
    fn parse_ai_response(&mut self) -> bool {
        self.ai_assist.error_message = None;
        self.ai_assist.success_message = None;
        self.ai_assist.parsed_pattern = None;
        self.ai_assist.test_result = None;
        self.ai_assist.pattern_tested = false;

        let json_str = self.ai_assist.json_response.trim();
        if json_str.is_empty() {
            return false;
        }

        // Try to extract JSON if wrapped in markdown code block
        let json_str = if json_str.starts_with("```") {
            json_str
                .lines()
                .skip(1)
                .take_while(|line| !line.starts_with("```"))
                .collect::<Vec<_>>()
                .join("\n")
        } else {
            json_str.to_string()
        };

        match serde_json::from_str::<AiGeneratedPattern>(&json_str) {
            Ok(pattern) => {
                self.ai_assist.parsed_pattern = Some(pattern);
                self.ai_assist.success_message = Some(t::grok_ai_parse_success().to_string());
                true
            }
            Err(e) => {
                self.ai_assist.error_message =
                    Some(format!("{}: {}", t::grok_ai_invalid_json(), e));
                false
            }
        }
    }

    /// Test the AI pattern with sample lines
    fn test_ai_pattern(&mut self, parser: &mut GrokParser) {
        self.ai_assist.test_result = None;

        if let Some(pattern) = &self.ai_assist.parsed_pattern {
            if !self.ai_assist.sample_lines.is_empty() {
                // Try to compile and test the pattern
                let test_line = &self.ai_assist.sample_lines[0];

                // Apply pre-processor if needed
                let processed_line = if let Some(ref pre_proc) = pattern.pre_processor {
                    match pre_proc {
                        AiPreProcessorConfig::JsonField { field } => {
                            // Try to parse as JSON and extract field
                            if let Ok(json) = serde_json::from_str::<serde_json::Value>(test_line) {
                                json.get(field)
                                    .and_then(|v| v.as_str())
                                    .unwrap_or(test_line)
                                    .to_string()
                            } else {
                                test_line.clone()
                            }
                        }
                    }
                } else {
                    test_line.clone()
                };

                // Test pattern without mutating parser state
                match parser.test_custom_pattern(
                    &pattern.name,
                    &pattern.pattern,
                    Some(&pattern.display_template),
                    &processed_line,
                ) {
                    Ok(Some(result)) => {
                        if !result.fields.is_empty() {
                            // Convert HashMap to Vec for storage, sorted to avoid flickering
                            let mut fields: Vec<(String, String)> =
                                result.fields.into_iter().collect();
                            fields.sort_by(|a, b| a.0.cmp(&b.0));
                            self.ai_assist.test_result = Some(Ok(fields));
                        } else {
                            self.ai_assist.test_result = Some(Ok(vec![]));
                        }
                    }
                    Ok(None) => {
                        self.ai_assist.test_result = Some(Ok(vec![]));
                    }
                    Err(_) => {
                        self.ai_assist.test_result =
                            Some(Err("ç¼–è¯‘é”™è¯¯: æ— æ³•ç¼–è¯‘æ¨¡å¼".to_string()));
                    }
                }
            }
        }
    }

    /// Show the grok panel
    pub fn show(&mut self, ui: &mut Ui, parser: &mut GrokParser) -> GrokPanelAction {
        let mut action = GrokPanelAction::None;

        ui.set_min_width(200.0);

        egui::ScrollArea::vertical()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                ui.add_space(8.0);
                ui.heading(RichText::new(t::grok_parser()).strong());
                ui.add_space(4.0);
                ui.label(RichText::new(t::grok_panel_hint()).weak().italics().small());
                ui.add_space(12.0);

                // Active pattern display (info only, selection is in status bar)
                let active_name = parser.active_pattern_name().map(|s| s.to_string());
                if let Some(name) = &active_name {
                    ui.group(|ui| {
                        ui.set_min_width(ui.available_width());
                        ui.horizontal(|ui| {
                            ui.label(RichText::new(t::grok_active_pattern()).strong());
                            ui.label(RichText::new(name).color(Color32::from_rgb(100, 200, 100)));
                        });
                    });
                    ui.add_space(8.0);
                } else {
                    ui.group(|ui| {
                        ui.set_min_width(ui.available_width());
                        ui.horizontal(|ui| {
                            ui.label(RichText::new(t::grok_active_pattern()).strong());
                            ui.label(RichText::new(t::grok_none()).weak().italics());
                        });
                    });
                    ui.add_space(8.0);
                }

                // Custom patterns section (main focus - for creating and editing patterns)
                self.show_custom_patterns(ui, parser, &mut action);
            });

        // Pattern editor dialog
        if self.pattern_editor.is_open {
            self.show_pattern_editor(ui, parser, &mut action);
        }

        action
    }

    /// Show custom patterns
    fn show_custom_patterns(
        &mut self,
        ui: &mut Ui,
        parser: &mut GrokParser,
        action: &mut GrokPanelAction,
    ) {
        // Clone the pattern info we need to avoid borrow conflicts
        let pattern_info: Vec<(String, String, String, String)> = parser
            .custom_patterns()
            .iter()
            .map(|p| {
                (
                    p.name.clone(),
                    p.pattern.clone(),
                    p.example.clone(),
                    p.display_template.clone(),
                )
            })
            .collect();

        if pattern_info.is_empty() {
            ui.label(RichText::new(t::grok_no_custom_patterns()).weak().italics());
        } else {
            let mut to_delete = None;
            let mut pattern_to_set: Option<(String, String, String, String)> = None;
            let mut pattern_to_edit: Option<usize> = None;

            for (i, (name, _pattern, _example, _template)) in pattern_info.iter().enumerate() {
                let is_selected = self.selected_custom == Some(i);

                ui.horizontal(|ui| {
                    if ui.selectable_label(is_selected, name).clicked() {
                        self.selected_custom = Some(i);
                        pattern_to_set = Some((
                            name.clone(),
                            _pattern.clone(),
                            _example.clone(),
                            _template.clone(),
                        ));
                    }

                    if ui
                        .small_button("âœ")
                        .on_hover_text(t::grok_edit_pattern())
                        .clicked()
                    {
                        pattern_to_edit = Some(i);
                    }

                    if ui
                        .small_button("ðŸ—‘")
                        .on_hover_text(t::grok_delete_pattern())
                        .clicked()
                    {
                        to_delete = Some(i);
                    }
                });
            }

            // Apply pattern change after iteration
            if let Some((name, pattern, _example, template)) = pattern_to_set {
                let template_opt = if template.is_empty() {
                    None
                } else {
                    Some(template.as_str())
                };
                if let Err(e) =
                    parser.set_custom_pattern_with_template(&name, &pattern, template_opt)
                {
                    tracing::error!("Failed to set custom pattern: {}", e);
                } else {
                    *action = GrokPanelAction::PatternChanged;
                }
            }

            // Handle edit after iteration
            if let Some(idx) = pattern_to_edit {
                if let Some(pattern) = parser.custom_patterns().get(idx) {
                    self.pattern_editor.load_from(pattern, idx);
                }
            }

            if let Some(idx) = to_delete {
                parser.remove_custom_pattern(idx);
                if self.selected_custom == Some(idx) {
                    self.selected_custom = None;
                    parser.clear_pattern();
                }
                *action = GrokPanelAction::ConfigChanged;
            }
        }

        ui.add_space(4.0);

        if ui.button(t::grok_add_pattern()).clicked() {
            self.pattern_editor.clear();
            self.pattern_editor.is_open = true;
        }
    }

    /// Show pattern editor dialog
    fn show_pattern_editor(
        &mut self,
        ui: &mut Ui,
        parser: &mut GrokParser,
        action: &mut GrokPanelAction,
    ) {
        let title = if self.pattern_editor.editing_index.is_some() {
            t::grok_edit_pattern()
        } else {
            t::grok_add_pattern()
        };

        let max_height = ui.ctx().input(|i| {
            i.viewport()
                .inner_rect
                .map(|r| r.height() * 0.7)
                .unwrap_or(700.0)
        });

        egui::Window::new(title)
            .collapsible(false)
            .resizable(true)
            .default_width(800.0)
            .default_height(700.0)
            .max_height(max_height)
            .show(ui.ctx(), |ui| {
                egui::ScrollArea::vertical()
                    .auto_shrink([false, false])
                    .show(ui, |ui| {
                        ui.horizontal(|ui| {
                            ui.label(t::grok_pattern_name());
                            ui.text_edit_singleline(&mut self.pattern_editor.name);
                        });

                        ui.add_space(4.0);

                        ui.label(t::grok_pattern_string());
                        ui.add(
                            egui::TextEdit::multiline(&mut self.pattern_editor.pattern)
                                .desired_width(ui.available_width())
                                .desired_rows(3)
                                .font(egui::TextStyle::Monospace),
                        );

                        ui.add_space(4.0);

                        ui.horizontal(|ui| {
                            ui.label(t::grok_pattern_description());
                            ui.text_edit_singleline(&mut self.pattern_editor.description);
                        });

                        ui.add_space(4.0);

                        ui.label(t::grok_pattern_example());
                        ui.add(
                            egui::TextEdit::multiline(&mut self.pattern_editor.example)
                                .desired_width(ui.available_width())
                                .desired_rows(2)
                                .font(egui::TextStyle::Monospace),
                        );

                        ui.add_space(8.0);

                        // Display template section
                        ui.label(RichText::new(t::grok_display_template()).strong());
                        ui.label(
                            RichText::new(t::grok_display_template_hint())
                                .weak()
                                .italics(),
                        );
                        ui.add(
                            egui::TextEdit::singleline(&mut self.pattern_editor.display_template)
                                .desired_width(ui.available_width())
                                .font(egui::TextStyle::Monospace)
                                .hint_text("%{timestamp} [%{level}] %{message}"),
                        );

                        ui.add_space(8.0);

                        // AI Assist section
                        ui.collapsing(RichText::new(t::grok_ai_assist()).strong(), |ui| {
                            self.show_ai_assist_in_editor(ui, parser, action);
                        });

                        ui.add_space(8.0);

                        // Test the pattern
                        if !self.pattern_editor.pattern.is_empty()
                            && !self.pattern_editor.example.is_empty()
                        {
                            match parser.test_pattern(
                                &self.pattern_editor.pattern,
                                &self.pattern_editor.example,
                            ) {
                                Ok(_) => {
                                    ui.label(
                                        RichText::new(t::grok_no_match()).color(Color32::YELLOW),
                                    );
                                }
                                Err(e) => {
                                    ui.label(RichText::new(format!("{}", e)).color(Color32::RED));
                                }
                            }
                        }

                        ui.add_space(8.0);

                        ui.horizontal(|ui| {
                            if ui.button(t::grok_save_pattern()).clicked()
                                && !self.pattern_editor.name.is_empty()
                                    && !self.pattern_editor.pattern.is_empty()
                                {
                                    let new_pattern = CustomPattern {
                                        name: self.pattern_editor.name.clone(),
                                        pattern: self.pattern_editor.pattern.clone(),
                                        description: self.pattern_editor.description.clone(),
                                        example: self.pattern_editor.example.clone(),
                                        enabled: true,
                                        display_template: self
                                            .pattern_editor
                                            .display_template
                                            .clone(),
                                        pre_processor: self.pattern_editor.pre_processor.clone(),
                                    };

                                    if let Some(idx) = self.pattern_editor.editing_index {
                                        // Update existing
                                        if let Some(p) = parser.custom_patterns_mut().get_mut(idx) {
                                            *p = new_pattern;
                                        }
                                    } else {
                                        // Add new
                                        parser.add_custom_pattern(new_pattern);
                                    }

                                    self.pattern_editor.clear();
                                    *action = GrokPanelAction::ConfigChanged;
                                }

                            if ui.button(t::grok_cancel()).clicked() {
                                self.pattern_editor.clear();
                            }
                        });
                    }); // ScrollArea
            });
    }

    /// Show AI assist in pattern editor
    fn show_ai_assist_in_editor(
        &mut self,
        ui: &mut Ui,
        parser: &mut GrokParser,
        action: &mut GrokPanelAction,
    ) {
        ui.label(RichText::new(t::grok_ai_prompt_hint()).weak().italics());
        ui.add_space(8.0);

        // Step 1: Copy prompt
        ui.horizontal(|ui| {
            if ui.button(t::grok_ai_copy_prompt()).clicked() {
                if self.ai_assist.generated_prompt.is_empty() {
                    self.ai_assist.pending_copy_prompt = true;
                    *action = GrokPanelAction::RequestSampleLines;
                } else {
                    ui.ctx().copy_text(self.ai_assist.generated_prompt.clone());
                    self.ai_assist.success_message = Some(t::grok_ai_prompt_copied().to_string());
                }
            }
        });

        // Show generated prompt
        if !self.ai_assist.generated_prompt.is_empty() {
            ui.add_space(8.0);
            ui.group(|ui| {
                egui::ScrollArea::vertical()
                    .max_height(150.0)
                    .show(ui, |ui| {
                        ui.add(
                            egui::TextEdit::multiline(
                                &mut self.ai_assist.generated_prompt.as_str(),
                            )
                            .desired_width(ui.available_width())
                            .font(egui::TextStyle::Monospace)
                            .interactive(false),
                        );
                    });
            });
        } else if self.current_file_path.is_none() {
            ui.label(RichText::new(t::grok_ai_no_file_open()).color(Color32::YELLOW));
        }

        ui.add_space(8.0);

        if self.ai_assist.pending_copy_prompt && !self.ai_assist.generated_prompt.is_empty() {
            ui.ctx().copy_text(self.ai_assist.generated_prompt.clone());
            self.ai_assist.success_message = Some(t::grok_ai_prompt_copied().to_string());
            self.ai_assist.pending_copy_prompt = false;
        }

        // Step 2: Paste prompt result
        ui.horizontal(|ui| {
            if ui.button(t::grok_ai_paste_json()).clicked() {
                // Try to read from clipboard using egui's input
                if let Some(text) = ui.ctx().input(|i| {
                    // Check for paste events
                    for event in &i.raw.events {
                        if let egui::Event::Paste(s) = event {
                            return Some(s.clone());
                        }
                    }
                    None
                }) {
                    self.ai_assist.json_response = text;
                } else {
                    // If no paste event, manually request paste
                    // User will need to paste manually after clicking
                    self.ai_assist.show_response_editor = true;
                    self.ai_assist.error_message = Some("è¯·æŒ‰Ctrl+Vç²˜è´´JSONå“åº”".to_string());
                    return;
                }

                if self.parse_ai_response() {
                    // Test the pattern with sample lines (only once)
                    if !self.ai_assist.pattern_tested {
                        self.test_ai_pattern(parser);
                        self.ai_assist.pattern_tested = true;
                    }
                    // Fill the pattern editor with AI generated content
                    if let Some(ref pattern) = self.ai_assist.parsed_pattern {
                        self.pattern_editor.name = pattern.name.clone();
                        self.pattern_editor.pattern = pattern.pattern.clone();
                        self.pattern_editor.description = pattern.description.clone();
                        self.pattern_editor.display_template = pattern.display_template.clone();
                        if let Some(first_sample) = self.ai_assist.sample_lines.first() {
                            self.pattern_editor.example = first_sample.clone();
                        }
                        if let Some(ref pre_proc) = pattern.pre_processor {
                            self.pattern_editor.pre_processor = pre_proc.to_pre_processor();
                        }
                    }
                }
                self.ai_assist.show_response_editor = true;
            }
        });

        // Show text area for manual paste if needed
        if self.ai_assist.show_response_editor {
            ui.add_space(4.0);
            let response = ui.add(
                egui::TextEdit::multiline(&mut self.ai_assist.json_response)
                    .desired_width(ui.available_width())
                    .desired_rows(6)
                    .font(egui::TextStyle::Monospace)
                    .hint_text(t::grok_ai_json_placeholder()),
            );

            if response.changed()
                && self.parse_ai_response() {
                    // Test the pattern with sample lines (only once)
                    if !self.ai_assist.pattern_tested {
                        self.test_ai_pattern(parser);
                        self.ai_assist.pattern_tested = true;
                    }
                    // Fill the pattern editor with AI generated content
                    if let Some(ref pattern) = self.ai_assist.parsed_pattern {
                        self.pattern_editor.name = pattern.name.clone();
                        self.pattern_editor.pattern = pattern.pattern.clone();
                        self.pattern_editor.description = pattern.description.clone();
                        self.pattern_editor.display_template = pattern.display_template.clone();
                        if let Some(first_sample) = self.ai_assist.sample_lines.first() {
                            self.pattern_editor.example = first_sample.clone();
                        }
                        if let Some(ref pre_proc) = pattern.pre_processor {
                            self.pattern_editor.pre_processor = pre_proc.to_pre_processor();
                        }
                    }
                }
        }

        // Show error message
        if let Some(error) = &self.ai_assist.error_message {
            ui.add_space(4.0);
            ui.label(RichText::new(error).color(Color32::RED));
        }

        // Show success message
        if let Some(success) = &self.ai_assist.success_message {
            ui.add_space(4.0);
            ui.label(RichText::new(success).color(Color32::from_rgb(100, 200, 100)));
        }

        // Show preview if pattern parsed successfully
        if self.ai_assist.parsed_pattern.is_some() && !self.ai_assist.sample_lines.is_empty() {
            ui.add_space(8.0);
            ui.label(RichText::new(t::grok_ai_parse_preview()).strong());
            ui.add_space(4.0);

            match &self.ai_assist.test_result {
                Some(Ok(fields)) => {
                    if !fields.is_empty() {
                        ui.group(|ui| {
                            // Show first sample line
                            ui.label(RichText::new(t::grok_ai_sample_log()).weak().italics());
                            ui.label(
                                RichText::new(self.ai_assist.sample_lines.first().unwrap())
                                    .monospace()
                                    .weak(),
                            );
                            ui.add_space(4.0);
                            // Show formatted result
                            ui.label(
                                RichText::new(t::grok_ai_formatted_result())
                                    .weak()
                                    .italics(),
                            );
                            // Convert Vec to HashMap for template
                            let fields_map: std::collections::HashMap<String, String> =
                                fields.iter().cloned().collect();
                            if let Some(ref pattern) = self.ai_assist.parsed_pattern {
                                // Use apply_template_with_style to get formatted segments with colors
                                let (_, segments) =
                                    crate::grok_parser::CompiledPattern::apply_template_with_style(
                                        &pattern.display_template,
                                        &fields_map,
                                    );

                                // Create a LayoutJob to display segments with proper styling
                                let mut job = egui::text::LayoutJob::default();
                                for segment in segments {
                                    let color = if let Some((r, g, b)) = segment.color {
                                        egui::Color32::from_rgb(r, g, b)
                                    } else {
                                        // Use default text color
                                        ui.style().visuals.text_color()
                                    };

                                    let font_id = egui::FontId::new(
                                        ui.style()
                                            .text_styles
                                            .get(&egui::TextStyle::Monospace)
                                            .map(|f| f.size)
                                            .unwrap_or(12.0),
                                        egui::FontFamily::Monospace,
                                    );

                                    job.append(
                                        &segment.text,
                                        0.0,
                                        egui::text::TextFormat {
                                            font_id,
                                            color,
                                            ..Default::default()
                                        },
                                    );
                                }

                                ui.label(job);
                            }
                        });
                    } else {
                        ui.label(RichText::new(t::grok_no_match()).color(Color32::YELLOW));
                    }
                }
                Some(Err(e)) => {
                    ui.label(RichText::new(e).color(Color32::RED));
                }
                None => {}
            }
        }
    }
}
