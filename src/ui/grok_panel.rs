//! Grok Parser Panel
//!
//! Provides UI for configuring and testing grok patterns for log parsing.

use crate::config::{FileGrokConfig, InlineGrokPattern};
use crate::grok_parser::{BuiltinPattern, CustomPattern, GrokConfig, GrokParser};
use crate::i18n::Translations as t;
use egui::{self, Color32, RichText, Ui};
use std::path::PathBuf;

/// Actions from the grok panel
#[derive(Debug, Clone)]
pub enum GrokPanelAction {
    /// No action
    None,
    /// Pattern changed (needs to reparse logs)
    PatternChanged,
    /// Configuration changed (needs to save)
    ConfigChanged,
    /// File-specific pattern changed
    FilePatternChanged {
        path: PathBuf,
        config: Option<FileGrokConfig>,
    },
    /// Request sample log lines for AI assist
    RequestSampleLines,
}

/// State for editing a custom pattern
#[derive(Debug, Clone, Default)]
struct PatternEditor {
    /// Pattern name
    name: String,
    /// Pattern string
    pattern: String,
    /// Pattern description
    description: String,
    /// Example log line
    example: String,
    /// Display template for formatting output
    display_template: String,
    /// Whether we're editing an existing pattern
    editing_index: Option<usize>,
    /// Whether the editor is open
    is_open: bool,
}

impl PatternEditor {
    fn clear(&mut self) {
        self.name.clear();
        self.pattern.clear();
        self.description.clear();
        self.example.clear();
        self.display_template.clear();
        self.editing_index = None;
        self.is_open = false;
    }

    fn load_from(&mut self, pattern: &CustomPattern, index: usize) {
        self.name = pattern.name.clone();
        self.pattern = pattern.pattern.clone();
        self.description = pattern.description.clone();
        self.example = pattern.example.clone();
        self.display_template = pattern.display_template.clone();
        self.editing_index = Some(index);
        self.is_open = true;
    }
}

/// Grok parser panel component
pub struct GrokPanel {
    /// Whether grok parsing is enabled
    pub enabled: bool,
    /// Currently selected builtin pattern
    selected_builtin: Option<BuiltinPattern>,
    /// Currently selected custom pattern index
    selected_custom: Option<usize>,
    /// Test input text
    test_input: String,
    /// Test result (field name -> value)
    test_result: Option<Result<Vec<(String, String)>, String>>,
    /// Pattern editor state
    pattern_editor: PatternEditor,
    /// Custom pattern definition editor
    definition_editor: DefinitionEditor,
    /// AI assist state
    ai_assist: AiAssistState,
    /// Current file path (for per-file settings)
    pub current_file_path: Option<PathBuf>,
    /// Whether current file uses file-specific pattern
    pub use_file_specific: bool,
}

/// State for editing pattern definitions
#[derive(Debug, Clone, Default)]
struct DefinitionEditor {
    name: String,
    pattern: String,
}

/// State for AI-assisted pattern generation
#[derive(Debug, Clone, Default)]
pub struct AiAssistState {
    /// Generated prompt for LLM
    pub generated_prompt: String,
    /// JSON response from LLM
    pub json_response: String,
    /// Sample log lines
    pub sample_lines: Vec<String>,
    /// Error message
    pub error_message: Option<String>,
    /// Success message
    pub success_message: Option<String>,
    /// Parsed pattern from JSON (preview before applying)
    pub parsed_pattern: Option<AiGeneratedPattern>,
}

/// Pattern generated by AI
#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
pub struct AiGeneratedPattern {
    /// Pattern name
    pub name: String,
    /// Grok pattern string
    pub pattern: String,
    /// Display template
    pub display_template: String,
    /// Description (optional)
    #[serde(default)]
    pub description: String,
}

impl Default for GrokPanel {
    fn default() -> Self {
        Self::new()
    }
}

impl GrokPanel {
    /// Create a new grok panel
    pub fn new() -> Self {
        Self {
            enabled: false,
            selected_builtin: None,
            selected_custom: None,
            test_input: String::new(),
            test_result: None,
            pattern_editor: PatternEditor::default(),
            definition_editor: DefinitionEditor::default(),
            ai_assist: AiAssistState::default(),
            current_file_path: None,
            use_file_specific: false,
        }
    }

    /// Load state from config
    pub fn load_from_config(&mut self, config: &GrokConfig) {
        self.enabled = config.enabled;
        self.selected_builtin = config.builtin_pattern;
        // Custom pattern selection would need to be matched by name
    }

    /// Save state to config
    pub fn save_to_config(&self, config: &mut GrokConfig) {
        config.enabled = self.enabled;
        config.builtin_pattern = self.selected_builtin;
    }

    /// Set sample lines for AI assist
    pub fn set_sample_lines(&mut self, lines: Vec<String>) {
        self.ai_assist.sample_lines = lines;
        self.generate_ai_prompt();
    }

    /// Generate AI prompt from sample lines
    fn generate_ai_prompt(&mut self) {
        if self.ai_assist.sample_lines.is_empty() {
            self.ai_assist.generated_prompt.clear();
            return;
        }

        let sample_text = self
            .ai_assist
            .sample_lines
            .iter()
            .take(10)
            .enumerate()
            .map(|(i, line)| format!("{}. {}", i + 1, line))
            .collect::<Vec<_>>()
            .join("\n");

        self.ai_assist.generated_prompt = format!(
            r#"You are a log parsing expert. Analyze the following log lines and generate a Grok pattern to parse them.

Sample log lines:
{}

Please analyze these log lines and return a JSON object with the following structure:
{{
    "name": "Pattern name describing the log format",
    "pattern": "The Grok pattern string to parse these logs",
    "display_template": "Display template using %{{field}} placeholders",
    "description": "Brief description of what this pattern matches"
}}

Requirements:
1. The Grok pattern should extract meaningful fields like timestamp, log level, message, etc.
2. Use standard Grok patterns like %{{TIMESTAMP_ISO8601}}, %{{LOGLEVEL}}, %{{GREEDYDATA}}, etc.
3. The display_template should format the parsed fields nicely, e.g., "%{{timestamp}} [%{{level}}] %{{message}}"
4. Return ONLY the JSON object, no additional text or explanation.

Common Grok patterns you can use:
- %{{TIMESTAMP_ISO8601:timestamp}} - ISO 8601 timestamp
- %{{HTTPDATE:timestamp}} - HTTP date format
- %{{SYSLOGTIMESTAMP:timestamp}} - Syslog timestamp
- %{{LOGLEVEL:level}} - Log level (ERROR, WARN, INFO, DEBUG, etc.)
- %{{IP:ip}} - IP address
- %{{WORD:field}} - Single word
- %{{DATA:field}} - Any data (non-greedy)
- %{{GREEDYDATA:field}} - Any data (greedy, usually for message)
- %{{NUMBER:field}} - Number
- %{{INT:field}} - Integer
- %{{QUOTEDSTRING:field}} - Quoted string"#,
            sample_text
        );
    }

    /// Parse JSON response from AI
    fn parse_ai_response(&mut self) -> bool {
        self.ai_assist.error_message = None;
        self.ai_assist.success_message = None;
        self.ai_assist.parsed_pattern = None;

        let json_str = self.ai_assist.json_response.trim();
        if json_str.is_empty() {
            return false;
        }

        // Try to extract JSON if wrapped in markdown code block
        let json_str = if json_str.starts_with("```") {
            json_str
                .lines()
                .skip(1)
                .take_while(|line| !line.starts_with("```"))
                .collect::<Vec<_>>()
                .join("\n")
        } else {
            json_str.to_string()
        };

        match serde_json::from_str::<AiGeneratedPattern>(&json_str) {
            Ok(pattern) => {
                self.ai_assist.parsed_pattern = Some(pattern);
                true
            }
            Err(e) => {
                self.ai_assist.error_message =
                    Some(format!("{}: {}", t::grok_ai_invalid_json(), e));
                false
            }
        }
    }

    /// Show the grok panel
    pub fn show(&mut self, ui: &mut Ui, parser: &mut GrokParser) -> GrokPanelAction {
        let mut action = GrokPanelAction::None;

        ui.set_min_width(200.0);

        egui::ScrollArea::vertical()
            .auto_shrink([false, false])
            .show(ui, |ui| {
                ui.add_space(8.0);
                ui.heading(RichText::new(t::grok_parser()).strong());
                ui.add_space(4.0);
                ui.label(RichText::new(t::grok_panel_hint()).weak().italics().small());
                ui.add_space(12.0);

                // Active pattern display (info only, selection is in status bar)
                let active_name = parser.active_pattern_name().map(|s| s.to_string());
                if let Some(name) = &active_name {
                    ui.group(|ui| {
                        ui.set_min_width(ui.available_width());
                        ui.horizontal(|ui| {
                            ui.label(RichText::new(t::grok_active_pattern()).strong());
                            ui.label(RichText::new(name).color(Color32::from_rgb(100, 200, 100)));
                        });
                    });
                    ui.add_space(8.0);
                } else {
                    ui.group(|ui| {
                        ui.set_min_width(ui.available_width());
                        ui.horizontal(|ui| {
                            ui.label(RichText::new(t::grok_active_pattern()).strong());
                            ui.label(RichText::new(t::grok_none()).weak().italics());
                        });
                    });
                    ui.add_space(8.0);
                }

                // Custom patterns section (main focus - for creating and editing patterns)
                ui.collapsing(RichText::new(t::grok_custom_patterns()).strong(), |ui| {
                    self.show_custom_patterns(ui, parser, &mut action);
                });

                ui.add_space(8.0);

                // Pattern definitions section
                ui.collapsing(
                    RichText::new(t::grok_pattern_definitions()).strong(),
                    |ui| {
                        self.show_pattern_definitions(ui, parser, &mut action);
                    },
                );

                ui.add_space(8.0);

                // Test section
                ui.collapsing(RichText::new(t::grok_test_pattern()).strong(), |ui| {
                    self.show_test_section(ui, parser);
                });

                ui.add_space(8.0);

                // AI Assist section
                ui.collapsing(RichText::new(t::grok_ai_assist()).strong(), |ui| {
                    self.show_ai_assist_section(ui, parser, &mut action);
                });
            });

        // Pattern editor dialog
        if self.pattern_editor.is_open {
            self.show_pattern_editor(ui, parser, &mut action);
        }

        action
    }

    /// Show custom patterns
    fn show_custom_patterns(
        &mut self,
        ui: &mut Ui,
        parser: &mut GrokParser,
        action: &mut GrokPanelAction,
    ) {
        // Clone the pattern info we need to avoid borrow conflicts
        let pattern_info: Vec<(String, String, String, String)> = parser
            .custom_patterns()
            .iter()
            .map(|p| {
                (
                    p.name.clone(),
                    p.pattern.clone(),
                    p.example.clone(),
                    p.display_template.clone(),
                )
            })
            .collect();

        if pattern_info.is_empty() {
            ui.label(RichText::new(t::grok_no_custom_patterns()).weak().italics());
        } else {
            let mut to_delete = None;
            let mut pattern_to_set: Option<(String, String, String, String)> = None;
            let mut pattern_to_edit: Option<usize> = None;

            for (i, (name, _pattern, _example, _template)) in pattern_info.iter().enumerate() {
                let is_selected = self.selected_custom == Some(i);

                ui.horizontal(|ui| {
                    if ui.selectable_label(is_selected, name).clicked() {
                        self.selected_custom = Some(i);
                        self.selected_builtin = None;
                        pattern_to_set = Some((
                            name.clone(),
                            _pattern.clone(),
                            _example.clone(),
                            _template.clone(),
                        ));
                    }

                    if ui
                        .small_button("âœ")
                        .on_hover_text(t::grok_edit_pattern())
                        .clicked()
                    {
                        pattern_to_edit = Some(i);
                    }

                    if ui
                        .small_button("ðŸ—‘")
                        .on_hover_text(t::grok_delete_pattern())
                        .clicked()
                    {
                        to_delete = Some(i);
                    }
                });
            }

            // Apply pattern change after iteration
            if let Some((name, pattern, example, template)) = pattern_to_set {
                let template_opt = if template.is_empty() {
                    None
                } else {
                    Some(template.as_str())
                };
                if let Err(e) =
                    parser.set_custom_pattern_with_template(&name, &pattern, template_opt)
                {
                    tracing::error!("Failed to set custom pattern: {}", e);
                } else {
                    *action = GrokPanelAction::PatternChanged;
                    self.test_input = example;
                    self.run_test(parser);
                }
            }

            // Handle edit after iteration
            if let Some(idx) = pattern_to_edit {
                if let Some(pattern) = parser.custom_patterns().get(idx) {
                    self.pattern_editor.load_from(pattern, idx);
                }
            }

            if let Some(idx) = to_delete {
                parser.remove_custom_pattern(idx);
                if self.selected_custom == Some(idx) {
                    self.selected_custom = None;
                    parser.clear_pattern();
                }
                *action = GrokPanelAction::ConfigChanged;
            }
        }

        ui.add_space(4.0);

        if ui.button(t::grok_add_pattern()).clicked() {
            self.pattern_editor.clear();
            self.pattern_editor.is_open = true;
        }
    }

    /// Show pattern definitions (reusable sub-patterns)
    fn show_pattern_definitions(
        &mut self,
        ui: &mut Ui,
        parser: &mut GrokParser,
        action: &mut GrokPanelAction,
    ) {
        ui.label(
            RichText::new("Define reusable pattern components")
                .weak()
                .italics(),
        );
        ui.add_space(4.0);

        // Add new definition
        ui.horizontal(|ui| {
            ui.label(t::grok_definition_name());
            ui.text_edit_singleline(&mut self.definition_editor.name);
        });

        ui.horizontal(|ui| {
            ui.label(t::grok_definition_pattern());
            ui.text_edit_singleline(&mut self.definition_editor.pattern);
        });

        if ui.button(t::grok_add_definition()).clicked() {
            if !self.definition_editor.name.is_empty() && !self.definition_editor.pattern.is_empty()
            {
                parser.add_pattern_definition(
                    &self.definition_editor.name,
                    &self.definition_editor.pattern,
                );
                self.definition_editor.name.clear();
                self.definition_editor.pattern.clear();
                *action = GrokPanelAction::ConfigChanged;
            }
        }
    }

    /// Show test section
    fn show_test_section(&mut self, ui: &mut Ui, parser: &GrokParser) {
        ui.label(t::grok_test_input());
        let response = ui.add(
            egui::TextEdit::multiline(&mut self.test_input)
                .desired_width(ui.available_width())
                .desired_rows(3)
                .font(egui::TextStyle::Monospace),
        );

        if response.changed() {
            self.run_test(parser);
        }

        if ui.button(t::grok_test_pattern()).clicked() {
            self.run_test(parser);
        }

        ui.add_space(8.0);
        ui.label(RichText::new(t::grok_test_result()).strong());

        match &self.test_result {
            Some(Ok(fields)) if !fields.is_empty() => {
                egui::Grid::new("test_result_grid")
                    .num_columns(2)
                    .striped(true)
                    .show(ui, |ui| {
                        for (name, value) in fields {
                            ui.label(RichText::new(name).strong());
                            ui.label(RichText::new(value).monospace());
                            ui.end_row();
                        }
                    });
            }
            Some(Ok(_)) => {
                ui.label(RichText::new(t::grok_no_match()).color(Color32::YELLOW));
            }
            Some(Err(e)) => {
                ui.label(
                    RichText::new(format!("{}: {}", t::grok_pattern_error(), e))
                        .color(Color32::RED),
                );
            }
            None => {
                ui.label(RichText::new(t::grok_no_pattern_selected()).weak());
            }
        }
    }

    /// Run test with current pattern
    fn run_test(&mut self, parser: &GrokParser) {
        if !parser.has_active_pattern() {
            self.test_result = None;
            return;
        }

        if let Some(result) = parser.parse(&self.test_input) {
            let mut fields: Vec<(String, String)> = result.fields.into_iter().collect();
            fields.sort_by(|a, b| a.0.cmp(&b.0));
            self.test_result = Some(Ok(fields));
        } else {
            self.test_result = Some(Ok(Vec::new()));
        }
    }

    /// Show pattern editor dialog
    fn show_pattern_editor(
        &mut self,
        ui: &mut Ui,
        parser: &mut GrokParser,
        action: &mut GrokPanelAction,
    ) {
        let title = if self.pattern_editor.editing_index.is_some() {
            t::grok_edit_pattern()
        } else {
            t::grok_add_pattern()
        };

        egui::Window::new(title)
            .collapsible(false)
            .resizable(true)
            .default_width(400.0)
            .show(ui.ctx(), |ui| {
                ui.horizontal(|ui| {
                    ui.label(t::grok_pattern_name());
                    ui.text_edit_singleline(&mut self.pattern_editor.name);
                });

                ui.add_space(4.0);

                ui.label(t::grok_pattern_string());
                ui.add(
                    egui::TextEdit::multiline(&mut self.pattern_editor.pattern)
                        .desired_width(ui.available_width())
                        .desired_rows(3)
                        .font(egui::TextStyle::Monospace),
                );

                ui.add_space(4.0);

                ui.horizontal(|ui| {
                    ui.label(t::grok_pattern_description());
                    ui.text_edit_singleline(&mut self.pattern_editor.description);
                });

                ui.add_space(4.0);

                ui.label(t::grok_pattern_example());
                ui.add(
                    egui::TextEdit::multiline(&mut self.pattern_editor.example)
                        .desired_width(ui.available_width())
                        .desired_rows(2)
                        .font(egui::TextStyle::Monospace),
                );

                ui.add_space(8.0);

                // Display template section
                ui.label(RichText::new(t::grok_display_template()).strong());
                ui.label(
                    RichText::new(t::grok_display_template_hint())
                        .weak()
                        .italics(),
                );
                ui.add(
                    egui::TextEdit::singleline(&mut self.pattern_editor.display_template)
                        .desired_width(ui.available_width())
                        .font(egui::TextStyle::Monospace)
                        .hint_text("%{timestamp} [%{level}] %{message}"),
                );

                ui.add_space(8.0);

                // Test the pattern
                if !self.pattern_editor.pattern.is_empty()
                    && !self.pattern_editor.example.is_empty()
                {
                    match parser
                        .test_pattern(&self.pattern_editor.pattern, &self.pattern_editor.example)
                    {
                        Ok(result) if !result.is_empty() => {
                            ui.label(RichText::new(t::grok_parsed_fields()).strong());
                            for (name, value) in result.fields.iter() {
                                ui.horizontal(|ui| {
                                    ui.label(RichText::new(name).strong());
                                    ui.label(RichText::new(value).monospace());
                                });
                            }

                            // Show formatted preview if template is set
                            if !self.pattern_editor.display_template.is_empty() {
                                ui.add_space(8.0);
                                ui.label(RichText::new(t::grok_formatted_preview()).strong());
                                let formatted = crate::grok_parser::CompiledPattern::apply_template(
                                    &self.pattern_editor.display_template,
                                    &result.fields,
                                );
                                ui.label(
                                    RichText::new(&formatted)
                                        .monospace()
                                        .color(Color32::from_rgb(100, 200, 100)),
                                );
                            }
                        }
                        Ok(_) => {
                            ui.label(RichText::new(t::grok_no_match()).color(Color32::YELLOW));
                        }
                        Err(e) => {
                            ui.label(RichText::new(format!("{}", e)).color(Color32::RED));
                        }
                    }
                }

                ui.add_space(8.0);

                ui.horizontal(|ui| {
                    if ui.button(t::grok_save_pattern()).clicked() {
                        if !self.pattern_editor.name.is_empty()
                            && !self.pattern_editor.pattern.is_empty()
                        {
                            let new_pattern = CustomPattern {
                                name: self.pattern_editor.name.clone(),
                                pattern: self.pattern_editor.pattern.clone(),
                                description: self.pattern_editor.description.clone(),
                                example: self.pattern_editor.example.clone(),
                                enabled: true,
                                display_template: self.pattern_editor.display_template.clone(),
                            };

                            if let Some(idx) = self.pattern_editor.editing_index {
                                // Update existing
                                if let Some(p) = parser.custom_patterns_mut().get_mut(idx) {
                                    *p = new_pattern;
                                }
                            } else {
                                // Add new
                                parser.add_custom_pattern(new_pattern);
                            }

                            self.pattern_editor.clear();
                            *action = GrokPanelAction::ConfigChanged;
                        }
                    }

                    if ui.button(t::grok_cancel()).clicked() {
                        self.pattern_editor.clear();
                    }
                });
            });
    }

    /// Show AI assist section
    fn show_ai_assist_section(
        &mut self,
        ui: &mut Ui,
        parser: &mut GrokParser,
        action: &mut GrokPanelAction,
    ) {
        ui.label(RichText::new(t::grok_ai_prompt_hint()).weak().italics());
        ui.add_space(8.0);

        // Step 1: Generate prompt
        ui.horizontal(|ui| {
            if ui.button(t::grok_ai_generate_prompt()).clicked() {
                *action = GrokPanelAction::RequestSampleLines;
            }
        });

        // Show generated prompt
        if !self.ai_assist.generated_prompt.is_empty() {
            ui.add_space(8.0);
            ui.group(|ui| {
                ui.set_min_width(ui.available_width());

                egui::ScrollArea::vertical()
                    .max_height(150.0)
                    .show(ui, |ui| {
                        ui.add(
                            egui::TextEdit::multiline(
                                &mut self.ai_assist.generated_prompt.as_str(),
                            )
                            .desired_width(ui.available_width())
                            .font(egui::TextStyle::Monospace)
                            .interactive(false),
                        );
                    });

                ui.add_space(4.0);
                if ui.button(t::grok_ai_copy_prompt()).clicked() {
                    ui.ctx().copy_text(self.ai_assist.generated_prompt.clone());
                    self.ai_assist.success_message = Some(t::grok_ai_prompt_copied().to_string());
                }
            });
        } else if self.current_file_path.is_none() {
            ui.label(RichText::new(t::grok_ai_no_file_open()).color(Color32::YELLOW));
        }

        ui.add_space(8.0);

        // Step 2: Paste JSON response
        ui.label(RichText::new(t::grok_ai_paste_json()).strong());
        let response = ui.add(
            egui::TextEdit::multiline(&mut self.ai_assist.json_response)
                .desired_width(ui.available_width())
                .desired_rows(6)
                .font(egui::TextStyle::Monospace)
                .hint_text(t::grok_ai_json_placeholder()),
        );

        if response.changed() {
            self.parse_ai_response();
        }

        // Show error message
        if let Some(error) = &self.ai_assist.error_message {
            ui.add_space(4.0);
            ui.label(RichText::new(error).color(Color32::RED));
        }

        // Show success message
        if let Some(success) = &self.ai_assist.success_message {
            ui.add_space(4.0);
            ui.label(RichText::new(success).color(Color32::from_rgb(100, 200, 100)));
        }

        // Show parsed pattern preview
        if let Some(pattern) = &self.ai_assist.parsed_pattern.clone() {
            ui.add_space(8.0);
            ui.group(|ui| {
                ui.set_min_width(ui.available_width());
                ui.label(RichText::new(&pattern.name).strong());

                ui.label(RichText::new("Pattern:").strong());
                ui.label(RichText::new(&pattern.pattern).monospace().weak());

                ui.add_space(4.0);
                ui.label(RichText::new("Template:").strong());
                ui.label(
                    RichText::new(&pattern.display_template)
                        .monospace()
                        .color(Color32::from_rgb(100, 200, 100)),
                );

                if !pattern.description.is_empty() {
                    ui.add_space(4.0);
                    ui.label(RichText::new(&pattern.description).weak().italics());
                }

                ui.add_space(8.0);
                ui.horizontal(|ui| {
                    // Apply pattern button
                    if ui.button(t::grok_ai_apply_pattern()).clicked() {
                        // Apply to current file as inline pattern
                        if let Some(path) = &self.current_file_path.clone() {
                            let inline_pattern = InlineGrokPattern {
                                name: pattern.name.clone(),
                                pattern: pattern.pattern.clone(),
                                display_template: pattern.display_template.clone(),
                            };

                            let file_config = FileGrokConfig {
                                enabled: true,
                                pattern_type: "inline".to_string(),
                                builtin_pattern: None,
                                custom_pattern_name: None,
                                inline_pattern: Some(inline_pattern.clone()),
                            };

                            // Set the pattern on the parser for immediate use
                            let template = if pattern.display_template.is_empty() {
                                None
                            } else {
                                Some(pattern.display_template.as_str())
                            };

                            if parser
                                .set_custom_pattern_with_template(
                                    &pattern.name,
                                    &pattern.pattern,
                                    template,
                                )
                                .is_ok()
                            {
                                self.enabled = true;
                                self.use_file_specific = true;
                                *action = GrokPanelAction::FilePatternChanged {
                                    path: path.clone(),
                                    config: Some(file_config),
                                };
                                self.ai_assist.success_message =
                                    Some(t::grok_ai_pattern_applied().to_string());
                                self.ai_assist.error_message = None;
                            }
                        }
                    }

                    // Save as custom pattern button
                    if ui.button(t::grok_ai_save_as_custom()).clicked() {
                        let new_pattern = CustomPattern {
                            name: pattern.name.clone(),
                            pattern: pattern.pattern.clone(),
                            description: pattern.description.clone(),
                            example: self
                                .ai_assist
                                .sample_lines
                                .first()
                                .cloned()
                                .unwrap_or_default(),
                            enabled: true,
                            display_template: pattern.display_template.clone(),
                        };
                        parser.add_custom_pattern(new_pattern);
                        *action = GrokPanelAction::ConfigChanged;
                        self.ai_assist.success_message =
                            Some(t::grok_ai_pattern_applied().to_string());
                    }
                });
            });
        }
    }
}
